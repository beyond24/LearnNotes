# 数据结构

## 绪论

### 基本概念和术语

**数据**：数据是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。如图片、声音等。

**数据元素** ：数据元素是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为**元素**、**记录**等。数据元素用于完整地描述一个对象，如一名学生记录。

**数据项**：数据项是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。

**数据对象**：数据对象是性质相同的数据元素的集合，是数据的一个子集。如一个学生表的基本信息表。

case：两张学生基本信息表和课程表都称为**数据**，单独的一张表如学生表就称为数据对象，表中的每一行元素如（张三 男 计科学院 ）就称为**数据元素**，而姓名、性别、学院就称为**数据项**。

**数据结构**：在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。**数据结构**是相互之间存在**一种或多种**特定关系的数据元素的集合。数据结构包括三方面的内容：**逻辑结构、存储结构和数据的运算。**

- 逻辑结构
   - 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。
   - 数据的逻辑结构分为**线性结构**和**非线性结构**
       - **集合** 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合
       - **线性结构** 结构中的数据元素之间只存在**一对一**的关系。比如排队。
       - **树形结构** 结构中的数据元素之间存在**一对多**的关系。比如家族族谱。
       - **图状结构或网状结构** 结构中的数据元素之间存在**多对多**的关系。 比如地图。

- 存储结构（物理结构）

   - 存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。
   - **顺序存储**：存储的物理位置相邻。
     - **链接存储**：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。
     - **索引存储**：类似于目录，以后可以联系操作系统的文件系统章节来理解。
     - **散列存储**：通过关键字直接计算出元素的物理地址（以后详解）。
     - Ps:  **顺序存储结构和链式存储结构**是数据元素计算机中**两种基本**的存储结构。

### 算法

程序 = 数据结构 + 算法(求解问题的步骤)

- 算法的**五个特征**
  - 1，有穷性：有限步之后结束
  - 2，确定性：不存在二义性，即没有歧义
  - 3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。
  - 4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。
  - 5，输出：一至多个程序输出结果。

- “好”算法的特质
  - 正确性：正确解决问题。
  - 可读性：代码使人能容易看懂。
  - 健壮性：输入非法数据时有错误处理。
  - 高效率与低存储量需求：时间复杂度和空间复杂度低。

### *算法的复杂度

- 时间复杂度：

  - 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；
  - 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级
  - T(n)=O(f(n)) f(n)是算法中基本运算的频度 **一般我们考虑最坏情况**下的时间复杂度

- 空间复杂度：

  - 它用来衡量算法随着问题规模增大，算法所需空间的快慢；
  - 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。

- 时间复杂度的计算

  - 常用的算法复杂度大小关系：**O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2n) < O(n!) < O(nⁿ).    （常对幂指阶）**  
  - 算法复杂度计算（单个循环体）
    - 直接关注循环体的执行次数，设为k

- 算法复杂度计算（多个循环体）

  - 两个运算规则：乘法规则，加法规则。
    - 加法规则： T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))
    - 乘法规则： T(n) = T1(n) x T2(n) = O(f(n)) x O(g(n)) = O(f(n) x g(n))
    - Eg:   T3 = n³ + n²logn = O(n³) + O(n²logn) = O(n³)

- case：

  ~~~c
  void loveYou(int n){	//n为问题规模
  		int flag[n];	//声明一个数组
  		//...省略数组初始化代码
  		if (n>1){
  			loveYou(n-1)
  		}
  	printf("I love you %d\n", n);
  }
  ~~~

  - 时间复杂度： T(n) = k * n = O(n)
  - 空间复杂度：S(n) = n + (n-1) + (n-2) ... +1 = (1/2)n² + (1/2)n = O(n²)

## 线性表

### 线性表的逻辑结构

- 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表。
- 特点：线性表中第一个元素称为**表头元素**；最后一个元素称为表尾元素。 除第一个元素外，每个元素有且仅有一个**直接前驱**。 除最后一个元素外，每个元素有且仅有一个**直接后继**。

### 线性表的顺序存储结构

- 线性表的顺序存储又称为**顺序表**。 它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

- 建立顺序表的三个属性: 1.存储空间的**起始位置**（数组名data） 2.顺序表**最大存储容量**（MaxSize） 3.顺序表当前的**长度**（length）

  > ~~~c
  > //静态分配的顺序表
  > #define MaxSize 10 //定义最大长度
  > typedef struct{
  > 	int data[MaxSize]; //用静态的“数组”存放数据元素
  > 	int lenght;	//顺序表的当前长度
  > } SqList;	//顺序表的类型定义
  > 
  > void InitList(SqList &L){ //&L代表引入全局变量，可以在函数体内改变L的值
  > 	for (int i = 0; i < MaxSize; i++)
  > 		 L.data[i] = 0;	//将所有元素初始值设为0，防止存在“垃圾值”
  > 	L.lenght = 0; //初始长度为0
  > }
  > ~~~

- 其实数组还可以**动态分配**空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配。（如使用C语言中的**malloc**函数，动态分配的优点是不会浪费内存空间）

  > ~~~c
  > //动态分配的顺序表
  > #include <stdlib.h>		//malloc所在的头文件
  > #define InitSize 10
  > typedef struct{
  > 	int *data;	//定义指针变量data，它始终指向动态数组的区域
  > 	int MaxSize; 
  > 	int length; //当前长度
  > }SeqList;
  > 
  > void InitList(SeqList &L){
  > 	L.data = (int *)malloc(InitSize * sizeof(int));
  > 	L.length = 0;
  > 	L.MaxSize = InitSize;
  > }
  > //增加动态数组的长度
  > void IncreaseSize(SeqList &L, int len){
  > 	int * p = L.data;
  > 	L.data = (int *)malloc((L.MaxSize + len) * sizeof(int));
  > 	for(int i = 0; i < L.length; i++){
  > 		L.data[i] = p[i];	//依次将数据复制到新的区域
  > 	}
  > 	L.MaxSize = L.MaxSize + len; //重置最大长度
  > 	free(p);	//释放原来的内存空间
  > }
  > ~~~

- 优点：

  - 1.顺序表最主要的特点是**随机访问**（C语言中基于数组），即通过首地址和元素序号可以在**O(1)**的时间内找到指定的元素。
  - 2.顺序表的**存储密度高**，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）。
- 缺点：

  - 顺序表逻辑上相邻的元素物理上也相邻，**需要使用大片连续空间**，并且**插入和删除操作需要移动大量元素**。

#### 顺序表的操作

- 1.**插入**

  - 算法思路：

    - 1.判断i的值是否正确
    - 2.判断表长是否超过数组长度
    - 3.从后向前到第i个位置，分别将这些元素都向后移动一位
    - 4.将该元素插入位置i 并修改表长

  - 代码(以静态分配的顺序表为例)

    > ~~~c
    > //在顺序表第i位添加元素e
    > bool ListInsert(SqList &L, int i, int e){
    > 	if (i < 1  || i > L.length + 1 || L.length >= MaxSize)	// 处理输入不合法的数据
    > 		return false;
    > 	for (int j = L.length - 1; j >= i - 1; j--)		//从线性表的末尾处开始处理依次将前一个数据向后移一位，直到第i个移动完成
    > 		L.data[j+1] = L.data[j];
    > 	L.data[i-1] = e;	//将新元素插入
    > 	L.length++;
    > 	return true;
    > } 
    > ~~~

  - 分析：

    - 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。
    - 最坏情况：在表头插入（即i=1），元素后移语句将执行 n次，时间复杂度为O(n)。
    - 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入 一个结点的概率，则在长度为n的线性表中插入一个结 点时所需移动结点的平均次数为(n+n-1+n-2+...+1)*(1/(n+1)) = n/2；因此**平均时间复杂度O(n) = n**

- 2.**删除**

  - 算法思路：
    - 1.判断i的值是否正确
    - 2.存取删除的元素
    - 3.将被删元素后面的所有元素都依次向前移动一位
    - 4.修改表长
  - 代码

  > ~~~c
  > //删除顺序表中第i个元素
  > bool ListDelete(SqList &L, int i, &e){	//使用e将删除的数字返回主程序
  > 	if (i < 1  || i > L.length) //此时的i的合法范围为1 <= i <= L.length
  > 		return false;
  >   e = L.data[i-1];
  > 	for (int j = i; j <= L.length; j++)	//从i后的第一个元素开始直至表尾
  > 		L.data[j-1] = L.data[j];	//所有的元素向前移动一位
  > 	L.length--;
  > 	return true;
  > }
  > ~~~

  - 分析
    - 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。
    - 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。
    - 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为(n-1+n-2+...+1)*(1/n) = n/2；因此**平均时间复杂度O(n) = n**

- 查找

  - 按位查找

    > ~~~c
    > //查找表中第i个元素并返回其值
    > Elemtype GetElem(SeqLIst L, int i){
    > 	return L.data[i-1];	//即使动态顺序表中data类型为指针在计算机中也可以通过数组+下标的方式查找
    > }
    > ~~~

  - 按值查找

    > ~~~c
    > //按值查找元素是否在表中，若在则返回其位序
    > int LocateELem(SeqList L, ElemType e){
    >   for(int i = 0; i <= L.length; i++)
    >     if(L.data[i] == e)	//若元素为更复杂的结构体则不能直接使用‘==’，可以使用合并if语句实现
    >       return i+1;
    >   return 0;
    > }
    > ~~~

### *线性表的链式存储结构

- 线性表的链式存储是指通过一组**任意的**存储单元来存储线性表中的数据元素。
- 头结点和头指针
  - 不管带不带头结点，头指针始终指向链表的第一个结点
  - 头结点是带头结点链表中的第一个结点，结点内通常不存储信息
  - 可以没有头节点不可以没有头指针
- 为什么要设置头结点？
  - 1.**处理操作起来方便** 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了
  - 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。
- 优点：
  - 不要求大量连续空间，改变容量方便
- 缺点
  - 不可随机存取，要耗费一定空间存放指针

#### 单链表

- 创建**不带头节点**的单链表

  >  	~~~c
  >  	//不带头节点的单链表
  >  	#include <stdio.h>
  >  	typedef struct LNode{
  >  		int data;	//data为数据域
  >  		struct LNode *next;		//定义一个next的指针变量用来指向下一个节点。结构体类型的变量，指针也用结构体声明
  >  	}LNode, *LinkList;	//这里语义为把结构体重命名为LNode,指向结构体的指针重命名为LinkList
  >  				
  >  	//一般用LinkList定义单链表，用LNode *定义指向单链表中某一节点的指针变量
  >  				
  >  	bool InitList(LinkList &L){
  >  		L = NULL;	//头指针指向null，空表
  >  		return true;
  >  	}
  >  	//判断单链表是否为空
  >  	bool Empty(LinkList L){
  >  		return (L == NULL);
  >  	}
  >  				
  >  	int main(){
  >  		LinkList L;		//声明一个指针变量L指向单链表，注意此时并非创建一个节点
  >  		InitList(L);	//初始化一个空表，完成后只有一个头指针L且指向NULL
  >  		if (Empty(L) == true)
  >  			printf("Link is null");
  >  		return 0;
  >  	}
  >  	~~~

- 创建**带头节点**的单链表

  > ~~~c
  > //带头节点的单链表
  > #include <stdio.h>
  > #include <stdlib.h>
  > typedef struct LNode{
  > 	int data;	//data为数据域
  > 	struct LNode *next;
  > }LNode, *LinkList;
  > 
  > bool InitList(LinkList &L){
  > 	L = (LNode *)malloc(sizeof(LNode)); //分配一个头节点，并使头指针指向头节点
  > 	if (L==NULL)	//内存空间不足，分配失败
  > 		return false;
  > 	L->next = NULL;		//L指向一个头节点结构体，所以使用“->”运算符代表L指向的头节点的next指针为NULL
  > 	return true;
  > }
  > //判断单链表是否为空
  > bool Empty(LinkList L){
  > 	return (L->next == NULL);
  > }
  > 
  > int main(){
  > 	LinkList L;
  > 	InitList(L);
  > 	if (Empty(L) == true)
  > 		printf("Link is null");
  > 	return 0;
  > }
  > ~~~

- 单链表的插入
  - 按位序插入

    > ~~~c
    > //以带头节点的单链表为例
    > //不带头节点的单链表需要单独处理头指针，其他的和带头节点的均相同
    > //按位序插入
    > bool LinkInsert(LinkList &L, int i, int e){
    > 	if (i < 1)
    > 		return false;
    > 	LNode *p;	
    > 	int j = 0; //j为p指向第几个结点，从头节点开始
    > 	p = L;	//L指向头结点，头结点是第0个元素（不存数据）
    > 	while (p != NULL && j < i-1){
    > 		p = p->next;
    > 		j++;
    > 	}
    > 	if (p==NULL)	//输入不合法
    > 		return false;
    > 	LNode *s = (LNode *)malloc(sizeof(LNode));	//定义指针变量s，指向一块新的结构体区域
    > 	
    > 	s->data = e;	//填入新数据
    > 	s->next = p->next;	//新数据的指针指向需要定位元素p的后一个元素
    > 	p->next = s;	//p的指针指向新元素
    > 
    > 	return true;	//插入成功
    > }
    > ~~~
    >
  
  - 指定节点的后插操作
  
    >~~~c
    >//在p结点后插入元素e
    >~~~

